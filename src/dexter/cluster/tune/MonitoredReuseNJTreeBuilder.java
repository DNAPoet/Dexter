package dexter.cluster.tune;

import java.util.*;
import dexter.cluster.*;
import dexter.util.LongBinCounter;


public class MonitoredReuseNJTreeBuilder<P> extends TreeBuilder<P> 
{
	private final static String[]	PHASES =
	{
		"Join neighbors", "Connect edges",  "Propagate tree"
	};
	
	// Structures for the NJ algorithm.
	private Collection<Node<P>>					nodesL;							// book calls this "L"
	private Collection<Node<P>>					nodesT;							// book calls this "T"
	private Vector<Edge<P>>						edges;							// TODO: convert to array
	private Map<Node<P>, Float>					nodeToR;						// my guess: "r" stands for radius
	private int									nOriginalLeafNodes;
	
	// Structures for converting edges generated by the algorithm to a tree.
	private Edge<P>								lastEdge;
	private Map<Node<P>, Vector<Edge<P>>> 		internalNodeToEdges;
	private int									nEdgesIncorporatedIntoTree;
	
	// For performance tuning: It's possible to reuse the nodeTo_r map several (many?) times
	// rather than recomputing it every time the nearest node pair is chosen and merged. If
	// reusing, the nearest n pairs of nodes are computed after the nodeTo_r map. If not
	// reusing, the nodeTo_r map and the nearest node pair are computed on the stack every pass 
	// through the main loop.
	private int									nReuses;						// 0 or 1 => don't reuse
	private Vector<Edge<P>>						preselectedNeighborPairs;		// only if reusing
	private float								oversampleFactor = -1f;			// neg => use default
	
	// There are 2 kinds of node: the original leaf nodes, and the generated internal nodes. This means
	// there are 3 combinations of nearest-neighbor pair: leaf-leaf, internal-internal, and mixed. 
	// Maybe there are phases of execution where most pairs are just one type. If so, we can reduce the
	// n of an O(n^2) operation by only comparing the appropriate pair types for a phase. The NJListener
	// receives distribution reports. Fingers crossed.
	private NJListener							njListener;						// receives reports, not threadsafe
	private LongBinCounter<EdgeMixture>  		edgeMixCounts;					// incremental
	private int 								joinReportInterval = 10;
		
	
	public MonitoredReuseNJTreeBuilder(DistanceMatrix<Node<P>> distanceMatrix) 
	{
		this(distanceMatrix, 0);
	}
	
	
	public MonitoredReuseNJTreeBuilder(DistanceMatrix<Node<P>> distanceMatrix, int nReuses) 
	{
		super(distanceMatrix, ClusterAlgorithm.NJ);		
		this.nReuses = nReuses;
		edges = new Vector<Edge<P>>();
	}
	
	
	private boolean doesOrthodoxNJ()
	{
		return preselectedNeighborPairs == null;
	}
	
		
	public Node<P> buildTree() 
	{
		// Inform listeners that clustering is starting.
		fireClusteringStarted();
		
		// Initialize.
		nodesL = new HashSet<Node<P>>(distanceMatrix.keys());			// unassigned nodes
		nodesT = new HashSet<Node<P>>(distanceMatrix.keys());			// product
		if (nReuses > 1)
			preselectedNeighborPairs = new Vector<Edge<P>>(nReuses);
		edgeMixCounts = new LongBinCounter<EdgeMixture>();

		// If tracking progress: 1st phase is to apply the NJ algorithm to generate edges.
		int totalEdgeGeneratingSteps = nodesL.size() - 2;
		int nEdgesGenerated = 0;
		startNewPhase(totalEdgeGeneratingSteps);
		
		// Iterate until only 2 nodes remain in L.
		Node<P> nodeI = null;		
		Node<P> nodeJ = null;
		float adjustedDij = 0f;
		float dn1n2 = 0f;
		while (nodesL.size() > 2)										// O(n)
		{
			// Precompute r for all nodes in L. If reusing, might also need to
			// precompute best n distances.
			nodeToR = computeRForAllNodes();
			if (!doesOrthodoxNJ()  &&  preselectedNeighborPairs.isEmpty())
			{
				ShortEdgeSelector<P> preselector = new ShortEdgeSelector<P>(nReuses, nodesL, distanceMatrix, nodeToR);
				if (oversampleFactor > 0)
					preselector.setOversamplingFactor(oversampleFactor);
				preselectedNeighborPairs = preselector.selectShortestEdges();
			}
			
			// "Pick a pair i,j, in L for which Dij is minimal." If implementing an orthodox
			// NJ algorithm, exhaustively scan all possible pairs of nodes. If reusing, pull
			// next pair from preselected list.
			nodeI = nodeJ = null;
			if (doesOrthodoxNJ())
			{
				adjustedDij = Float.MAX_VALUE;
				for (Node<P> n1: nodesL)									// O(n^2)
				{
					for (Node<P> n2: nodesL)								// O(n^3)
					{
						if (n1 == n2)
							continue;
						dn1n2 = bigD(n1, n2);
						if (dn1n2 < adjustedDij)
						{
							adjustedDij = dn1n2;
							nodeI = n1;
							nodeJ = n2;
						}
					}
				}
			}
			else
			{
				assert !preselectedNeighborPairs.isEmpty();
				Edge<P> nearestPair = preselectedNeighborPairs.remove(0);
				nodeI = nearestPair.node1;
				nodeJ = nearestPair.node2;
			}
			
			// "Define a new node k and set d(km) for all m in L (except i and j)." 
			Node<P> nodeK = new Node<P>();
			nodeK.setName("Internal_" + nextIntermediateNodeSN++);				// k is the new node - note no payload
			float dij = distanceMatrix.getDistance(nodeI, nodeJ);
			for (Node<P> nodeM: nodesL)
			{
				if (nodeM == nodeI  ||  nodeM == nodeJ)
					continue;
				float dim = distanceMatrix.getDistance(nodeI, nodeM);
				float djm = distanceMatrix.getDistance(nodeJ, nodeM);
				float dkm = (dim + djm - dij) / 2f;
				distanceMatrix.setDistance(nodeK, nodeM, dkm);
			}
			
			// "Add k to T with edges..."
			float dik = (dij + r(nodeI) - r(nodeJ)) / 2f;
			distanceMatrix.setDistance(nodeI, nodeK, dik);
			Edge<P> eik = new Edge<P>(nodeI, nodeK, dik);
			edges.add(eik);
			float djk = dij - dik;
			distanceMatrix.setDistance(nodeJ, nodeK, djk);
			Edge<P> ejk = new Edge<P>(nodeJ, nodeK, dik);
			edges.add(ejk);
			nodesT.add(nodeK);
			
			// "Remove i and j from L and add k."
			assert nodesL.contains(nodeI)  :  "nodeI = " + nodeI + " not in setL";
			assert nodesL.contains(nodeJ)  :  "nodeJ = " + nodeJ + " not in setL";
			nodesL.remove(nodeI);
			nodesL.remove(nodeJ);
			nodesL.add(nodeK);
			
			// Report progress. Threadsafe phase progress report goes to any cluster progress listeners.
			// Simpler single-listener notification goes to NJ listener if it's time to report LL/II/mixed
			// counts.
			reportPhaseProgress(++nEdgesGenerated);
			if (njListener != null)
			{
				EdgeMixture mix = getEdgeMixture(nodeI, nodeJ);
				edgeMixCounts.bumpCountForBin(mix);
				if (nodesL.size() % joinReportInterval == 0)
				{
					njListener.choseNodesToJoin(edgeMixCounts);
					edgeMixCounts.clear();
				}
			}
			
		}  // end of while-loop
		
		// Terminate main NJ loop. "When L consists of two leaves i and j
		// add the remaining edge between i and j, with length dij."
		// But it's more convenient for the tree-building step if we
		// cache the last edge without adding it to the collection until later.
		Iterator<Node<P>> iter = nodesL.iterator();
		nodeI = iter.next();
		nodeJ = iter.next();
		assert !iter.hasNext();
		lastEdge = new Edge<P>(nodeI, nodeJ, distanceMatrix.getDistance(nodeI, nodeJ)); 
		firePhaseFinished();
		
		// Build a tree from the collection of edges.
		Node<P> rootedTree = convertEdgesToRootedTree();
		fireClusteringFinished();
		return rootedTree;
	}  // End of buildTree()
	
		
	//
	// Defined as D-sub-ij on p. 170. Note capital D, versus d-sub-ij, which is the distance provided
	// in the table. The NJ distance is the distance in the table, minus the average distances ("r")
	// from nodes i and j to all other nodes. This metric can be negative; it is only used for picking
	// nearest neighbors.
	//
	// This method should only be called when the node-to-r map is valid. The map must be revised every 
	// time nodes are added to or removed from L.
	//
	// Called at a level with complexity = O(n^3)
	//
	private float bigD(Node<P> node1, Node<P> node2)
	{
		float r1 = nodeToR.get(node1);
		float r2 = nodeToR.get(node2);
		return distanceMatrix.getDistance(node1, node2) - r1 - r2;
	}
		
		
	// Defined as r-sub-i at the top of p. 171.
	private float r(Node<P> nodeI)
	{
		assert nodesL.size() > 2;
		
		float r = 0f;
		for (Node<P> nodeK: nodesL)
			if (nodeK != nodeI)
				r += distanceMatrix.getDistance(nodeI, nodeK);
		r /= (nodesL.size() - 2f);
		return r;
	}
	
	
	private Map<Node<P>, Float> computeRForAllNodes()
	{
		HashMap<Node<P>, Float> ret = new HashMap<Node<P>, Float>();
		for (Node<P> node: nodesL)
			ret.put(node, r(node));		
		return ret;
	}
	
		
		
		
		
						
		
		
					
						//////////////////////////////////////////////////////
						//                                                  //
						//                    CONVERSION                    //
						//                                                  //
						//////////////////////////////////////////////////////
					
					
	
	//
	// The algorithm produces a set of edges, which need to be converted to a rooted tree. The
	// last edge added is split in half and a root node is inserted.
	//
	private Node<P> convertEdgesToRootedTree()
	{
		// Insert root node in center of last edge added.
		Node<P> root = new Node<P>();
		root.setName("NEIGHBOR-JOINING ROOT");
		float halfLen = lastEdge.length / 2f;
		edges.add(new Edge<P>(root, lastEdge.node1, halfLen));
		edges.add(new Edge<P>(root, lastEdge.node2, halfLen));
		
		// Report start of this phase.
		startNewPhase(edges.size());
		int nEdgesConnected = 0;
				
		// Map internal nodes to edges. Internal nodes are connected to 3 edges, except for the 
		// root, which is connected to 2 edges.
		internalNodeToEdges = new HashMap<Node<P>, Vector<Edge<P>>>();
		for (Edge<P> edge: edges)
		{
			Iterator<Node<P>> iter = edge.nodeIterator();
			while (iter.hasNext())
			{
				Node<P> node = iter.next();
				if (node.getPayload() == null)
				{
					// Internal node, connected to 3 edges.
					Vector<Edge<P>> vec = internalNodeToEdges.get(node);
					if (vec == null)
					{
						vec = new Vector<Edge<P>>(3);
						internalNodeToEdges.put(node, vec);
					}
					vec.add(edge);
					assert vec.size() <= 3  :  "Node " + node + " has too many edges (expected <=3): " + vec.size();
				}
			}
			reportPhaseProgress(++nEdgesConnected);
		}
		firePhaseFinished();
		
		// Recursively build down from the nodes that were connected to the last edge added.
		startNewPhase(edges.size());
		recurseBuildTree(null, root);		// null grandparent because root has no parent
		firePhaseFinished();
		return root;
	}
	
		
	private void recurseBuildTree(Node<P> grandparent, Node<P> parent)
	{

		Vector<Edge<P>> edgesFromParent = internalNodeToEdges.get(parent);
		for (Edge<P> edge: edgesFromParent)
		{
			// There are 3 edges from the parent. The edge from the grandparent has already
			// been processed and should be ignored.
			Node<P> kid = edge.otherNode(parent);
			if (kid == grandparent)
				continue;
			
			// Connect parent to kid and recurse if kid is internal node.
			parent.addKid(kid, edge.length);
			reportPhaseProgress(++nEdgesIncorporatedIntoTree);
			if (kid.getPayload() == null)
				recurseBuildTree(parent, kid);
		}
	}

	
	
	
						
							
							
							//////////////////////////////////////////////////////////
							//                                                      //
							//                    JOIN STATISTICS                   //
							//                                                      //
							//////////////////////////////////////////////////////////
						
						

	
	
	// The NJ listener is called every n times a pair of neighboring nodes is joined.
	void setNJListener(NJListener listener)
	{
		this.njListener = listener;
	}
	
	
	void setJoinReportInterval(int joinReportInterval)
	{
		this.joinReportInterval = joinReportInterval;
	}
	
	
	
							
	
	
						
							
							
							/////////////////////////////////////////////////////////
							//                                                     //
							//                    TEST AND DEBUG                   //
							//                                                     //
							/////////////////////////////////////////////////////////


	
	
	// Only call on small collections.
	private Vector<Node<P>> sortNodes(Collection<Node<P>> unsorted)
	{
		Map<String, Node<P>> sorter = new TreeMap<String, Node<P>>();
		for (Node<P> node: unsorted)
			sorter.put(node.toString(), node);
		return new Vector<Node<P>>(sorter.values());
	}
		
	
	
		
		
		
		
		
							/////////////////////////////////////////////////////////
							//                                                     //
							//                    MISC AND MAIN                    //
							//                                                     //
							/////////////////////////////////////////////////////////

		
		
	
	public String[] getPhaseNames()
	{
		return PHASES;
	}
	
	
	public void setNReuses(int nReuses)
	{
		this.nReuses = nReuses;
	}
	
	
	public void setPreselectOversampleFactor(float f)
	{
		oversampleFactor = f;
	}
	
	
	private boolean nodeIsLeaf(Node<P> node)
	{
		return node.getPayload() != null;
	}
	
	
	private boolean nodeIsInternal(Node<P> node)
	{
		return !nodeIsLeaf(node);
	}
	
	
	EdgeMixture getEdgeMixture(Node<P> node1, Node<P> node2)
	{
		int nInternals = 0;
		if (nodeIsInternal(node1))
			nInternals++;
		if (nodeIsInternal(node2))
			nInternals++;
		
		switch (nInternals)
		{
			case 0:	return EdgeMixture.LL;
			case 1: return EdgeMixture.MIXED;
			default: return EdgeMixture.II;
		}
	}
	
	
	int getNOriginalLeafNodes()
	{
		return nOriginalLeafNodes;
	}
	
	
	public static void main(String[] args)
	{
		try
		{
			sop("START");	
			
			// Create nodes;
			int nNodes = 50;
			Vector<Node<String>> nodes = TreeBuilder.createStringPayloadNodes("Leaf_", nNodes, 0);
			
			// Create matrix with pseudo-random distances. Capacity needs to be 2x the number of original nodes.
			HalfArrayDistanceMatrix<Node<String>> distances = new HalfArrayDistanceMatrix<Node<String>>(nNodes*2);
			distances.randomize(nodes, 10, 100);
			
			// Create tree builder.
			MonitoredReuseNJTreeBuilder<String> treeBuilder = new MonitoredReuseNJTreeBuilder<String>(distances);
			treeBuilder.setNReuses(2);
			
			// Build tree.
			Node<String> tree = treeBuilder.buildTree();
			sop(tree.toStringWithIndent());
		}
		catch (Exception x)
		{
			sop("Stress: " + x.getMessage());
			x.printStackTrace();
		}
		sop("DONE");
	}
}
